(defun y (g)
  ((lambda (f) (funcall f f))
   (lambda (f) (funcall g (lambda (&rest x) (apply (funcall f f) x))))))

(defun gen-parallel-async ()
  ((lambda (wrap)
     (let ((list)
           (tasks)
           (singal))
       (sb-thread:make-thread
        (y (lambda (fn) (lambda ()
                     (setf list (append list tasks))
                     (setf tasks nil)
                     (let ((task (car list)))
                       (if (not (eq task nil))
                           (progn (setf list (cdr list))
                                  (print "go")
                                  (funcall
                                   (funcall wrap task))
                                  (sleep 0))
                           (progn (sleep 1)
                                  (print "sil")))
                       (cond ((equal singal :end) nil)
                             (t (funcall fn))))))))
       (values (list (cons :add (lambda (&rest task)
                                  (sleep 0)
                                  (setf tasks (append tasks task))))
                     (cons :end (lambda () (setf singal :end)))))))
   (lambda (fn)
     (lambda (&rest x)
       (handler-case (apply fn x)
         (error (condition) (print condition)))))))


;; (defparameter async (gen-parallel-async))
;; (funcall (cdr (assoc :end async)))
;; (times 3 (lambda (x) (times 2 (lambda (i) (funcall (cdr (assoc :add async)) (lambda () (progn (format t "~A : ~A~%" x i) (atomic-incf acc))))))))
(defun times (max f)
  (do ((i 0 (+ i 1)))
      ((>= i max) 'done)
    (funcall f i)))
;;(times 6 (funcall (cdr (assoc :add async)) (lambda () (format t "~%~A~%" i))))

(defglobal accx 0)
(declaim (fixnum accx))
(atomic-incf accx)
