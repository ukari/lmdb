(defun y (g)
  ((lambda (f) (funcall f f))
   (lambda (f) (funcall g (lambda (&rest x) (apply (funcall f f) x))))))

;;(defglobal tasknum 0)
;;(declaim (fixnum tasknum))

(defun gen-parallel-async ()
  ((lambda (wrap)
     (let ((tasks (queue))
           (singal))
       (sb-thread:make-thread
        (y (lambda (fn) (lambda ()
                     ;;(setf list (nconc list tasks))
                     ;;(setf tasks nil)
                     (let ((task (funcall (dot :de tasks))))
                       (if (not (eq task nil))
                           (progn
                             (print "go")
                             ;;(atomic-incf tasknum)
                             (funcall
                              (funcall wrap task)))
                           (progn (print "sil")))
                       (cond ((equal singal :end) nil)
                             (t (progn (if (eq task nil)
                                           (sleep 1)
                                           (sleep 0))
                                       (funcall fn)))))))))
       (values (list (cons :add (lambda (task)
                                  (funcall (dot :en tasks) task)))
                     (cons :end (lambda () (setf singal :end)))))))
   (lambda (fn)
     (lambda (&rest x)
       (handler-case (apply fn x)
         (error (condition) (print condition)))))))


;; (defparameter async (gen-parallel-async))
;; (funcall (cdr (assoc :end async)))
;; (times 3 (lambda (x) (times 2 (lambda (i) (funcall (cdr (assoc :add async)) (lambda () (progn (format t "~A : ~A~%" x i))))))))
(defun times (max f)
  (do ((i 0 (+ i 1)))
      ((>= i max) 'done)
    (funcall f i)))
;;(times 6 (funcall (cdr (assoc :add async)) (lambda () (format t "~%~A~%" i))))
(defun safe-update (list-single value)
  (atomic-update (car list-single) (lambda (value place) (setf place value)) value))

(defun safe-pointto (list-single key parameter &key (callback nil))
  (if (not (eq list-single nil))
      (atomic-update (cdr (assoc key list-single)) (lambda (value place)
                                                     (if (not (eq callback nil))
                                                         (funcall callback))
                                                     (setf place value)) parameter)))

(defun dot (key object)
  (cdr (assoc key object)))


;;(defparameter q (queue))
;;(defparameter pp (funcall (dot :en q) 1))
;;(funcall (dot :en q) 2)
(defun queue ()
  (labels ((node (e)
             (let ((node (list (cons :prev nil)
                               (cons :value (list e)))))
               node)))
    (let ((queue (list (cons :p-head nil)
                       (cons :p-tail nil))))
      (values (list (cons :en (lambda (e) (let ((node (node e)))
                                       (if (eq (dot :p-tail queue) nil)
                                           (safe-pointto queue :p-tail node))
                                       (safe-pointto queue :p-head node :callback (lambda () (safe-pointto (dot :p-head queue) :prev node)))
                                       queue)))
                    (cons :de (lambda () (let ((e))
                                      (safe-pointto queue :p-tail
                                                    (dot :prev (dot :p-tail queue))
                                                    :callback (lambda () (setf e (car (dot :value (dot :p-tail queue)))))) e))))))))
