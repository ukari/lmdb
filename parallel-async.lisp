(defun y (g)
  ((lambda (f) (funcall f f))
   (lambda (f) (funcall g (lambda (&rest x) (apply (funcall f f) x))))))

(defglobal tasknum 0)
(declaim (fixnum tasknum))

(defun gen-parallel-async ()
  ((lambda (wrap)
     (let ((tasks (queue))
           (singal))
       (sb-thread:make-thread
        (y (lambda (fn) (lambda ()
                     ;;(setf list (nconc list tasks))
                     ;;(setf tasks nil)
                     (let ((task (funcall (dot :de tasks))))
                       (if (not (eq task nil))
                           (progn
                             (print "go")
                                        ;(atomic-incf tasknum)
                             (funcall (funcall wrap task)))
                           (progn (print "sil")))
                       (cond ((equal singal :end) nil)
                             (t (progn (if (eq task nil)
                                           (sleep 1)
                                        ;(sleep 0)
                                           )
                                       (funcall fn)))))))))
       (values (list (cons :add (lambda (task)
                                  (funcall (dot :en tasks) task)))
                     (cons :end (lambda () (setf singal :end)))))))
   (lambda (fn)
     (lambda ()
       (handler-case (funcall fn)
         (error (condition) (print condition)))))))


;; (defparameter async (gen-parallel-async))
;; (funcall (cdr (assoc :end async)))
;; (times 3 (lambda (x) (times 2 (lambda (i) (funcall (cdr (assoc :add async)) (lambda () (progn (format t "~A : ~A~%" x i))))))))
(defun times (max f)
  (do ((i 0 (+ i 1)))
      ((>= i max) 'done)
    (funcall f i)))
;;(times 6 (funcall (cdr (assoc :add async)) (lambda () (format t "~%~A~%" i))))
(defun safe-update (list-single value)
  (atomic-update (car list-single) (lambda (value place) (setf place value)) value))

(defun safe-pointto (list-single key parameter &key (callback nil))
  (if (not (eq list-single nil))
      (atomic-update (cdr (assoc key list-single)) (lambda (value place)
                                                     (if (not (eq callback nil))
                                                         (funcall callback))
                                                     (setf place value)) parameter)))


(defun dot (key object)
  (cdr (assoc key object)))



;;(defparameter q (queue))
;;(defparameter pp (funcall (dot :en q) 1))
;;(funcall (dot :en q) 2)
(defun queue ()
  (labels ((node (e)
             (let ((node (list (cons :prev nil)
                               (cons :value (list e))
                               (cons :status (list t)))))
               node)))
    (let ((dummy (node nil)))
      (setf (car (dot :status dummy)) nil)
      (let ((queue (list (cons :p-head dummy)
                         (cons :p-tail dummy))))
        (values (list (cons :en (lambda (e) (let ((node (node e)))
                                        ;(safe-pointto queue :p-head node :callback (lambda () (safe-pointto (dot :p-head queue) :prev node)))
                                         (let ((head))
                                           (safe-pointto queue :p-head node :callback (lambda () (setf head (dot :p-head queue))))
                                           (safe-pointto head :prev node))
                                         queue)))
                      (cons :de (lambda () (let ((e))
                                        ((lambda (tail)
                                           (if (eq (car (dot :status tail)) nil)
                                               (if (eq (dot :prev tail) nil)
                                                   (setf e nil)
                                                   ((lambda (prev)
                                        ;(print queue)
                                                      (setf e (car (dot :value prev)))
                                                      (setf (cdr (assoc :p-tail queue)) prev);;maybe optimize
                                                      (setf (car (dot :status prev)) nil);;maybe optimize
                                        ;(print queue)
                                                      )
                                                    (dot :prev tail)))
                                               (setf e nil);;shouldn't walk here
                                               ))
                                         (dot :p-tail queue))
                                        e)))))))))


(defparameter aa (gen-parallel-async))
(defun test (number)
  (times number
         (lambda (n) (funcall (lambda (async)
                           (times 1
                                  (lambda (i)
                                    (funcall (dot :add async)
                                             (lambda ()
                                               (format t "~A : ~A~%" n i)
                                               (funcall (dot :add aa)
                                                        (lambda ()
                                                          (print i)
                                                          (atomic-incf tasknum)
                                                          (if (eq i 0)
                                                              (funcall (dot :end async))))))))))
                         (gen-parallel-async)))))
